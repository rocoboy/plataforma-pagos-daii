import { createClient } from "@/lib/supabase/server";
import { NextRequest } from "next/server";
import { Constants } from "@/lib/supabase/schema";
import { PaymentGateway, PaymentRequest } from "@/lib/payment-gateway";
import z from "zod";

export const createPaymentBodySchema = z.object({
  amount: z.number(),
  currency: z.enum(Constants.public.Enums.currency).optional(),
  user_id: z.string().optional(),
  meta: z.any().optional(),
  // Reservas-specific fields
  externalUserId: z.number().optional(),
  reservationId: z.number(), // Now required field, replaces res_id
  // Payment_status and PaymentEventId will be auto-generated by backend
});

export type PaymentStatus =
  (typeof Constants.public.Enums.payment_status)[number];

export type Currency = (typeof Constants.public.Enums.currency)[number];

export async function createPayment(
  request: NextRequest,
  amount: number,
  reservationId: number, // Required - moved to before optional parameters
  currency?: Currency,
  user_id?: string,
  meta?: unknown,
  externalUserId?: number
) {
  const supabase = createClient(request);

  if (!reservationId) {
    throw new Error("reservationId is required for payment creation");
  }

  const defaultPaymentStatus: PaymentStatus = "PENDING";

  // Use reservationId directly as the database res_id
  const payload: any = { 
    res_id: reservationId.toString(), // Convert reservationId directly to string for database
    status: defaultPaymentStatus, 
    amount
  };

  if (!currency) payload.currency = "ARS";

  if (user_id) payload.user_id = user_id;

  if (typeof meta !== "undefined") payload.meta = meta;

  // Add Reservas fields to meta object for storage
  const reservasFields: any = {};
  if (externalUserId) reservasFields.externalUserId = externalUserId;
  if (reservationId) reservasFields.reservationId = reservationId;
  
  // Auto-generate Payment_status (PaymentEventId will be set after insert)
  reservasFields.Payment_status = "PENDING"; // Always start with PENDING

  if (Object.keys(reservasFields).length > 0) {
    payload.meta = { 
      ...(payload.meta || {}), 
      reservas: reservasFields 
    };
  }

  // Insert initial payment record
  const { data, error } = await supabase
    .from("payments")
    .insert(payload)
    .select("*")
    .single();

  if (error) throw new Error(error.message);
  
  // Process through payment gateway if this is a Reservas payment
  if (data && (externalUserId || reservationId)) {
    // Create payment request for gateway (assuming card details are on file)
    const gatewayRequest: PaymentRequest = {
      amount: data.amount,
      currency: data.currency || 'ARS',
      // Simulate card details being on file - use safe test card
      cardNumber: '4111111111111111', // Visa test card
      cardHolder: `External User ${externalUserId}`,
      cvv: '123',
      expiryMonth: '12',
      expiryYear: '2028'
    };

    // Process through payment gateway
    const gateway = new PaymentGateway();
    const gatewayResponse = await gateway.processPayment(gatewayRequest);

    // Determine final status based on gateway response
    const finalStatus: PaymentStatus = gatewayResponse.success ? "SUCCESS" : "FAILURE";

    // Update payment with gateway results and PaymentEventId
    const updatedReservasFields = {
      ...reservasFields,
      Payment_status: finalStatus,
      PaymentEventId: data.id // Use the auto-generated Supabase ID
    };
    
    const existingMeta = (data.meta && typeof data.meta === 'object') ? data.meta as Record<string, any> : {};
    
    const { data: updatedData, error: updateError } = await supabase
      .from("payments")
      .update({
        status: finalStatus,
        meta: {
          ...existingMeta,
          reservas: updatedReservasFields,
          gateway_response: gatewayResponse.gatewayResponse,
          transaction_id: gatewayResponse.transactionId,
          error_code: gatewayResponse.errorCode,
          error_message: gatewayResponse.errorMessage,
          processed_at: new Date().toISOString(),
        }
      })
      .eq("id", data.id)
      .select("*")
      .single();
    
    if (updateError) throw new Error(updateError.message);
    return updatedData;
  }
  
  return data;
}
